from pathlib import Path
import re, html
from PIL import Image, ImageDraw, ImageFont
import imageio

REPORT = Path("reports/index.html")
ASSETS_DIR = Path("assets")
ASSETS_DIR.mkdir(parents=True, exist_ok=True)
OUT_PNG = ASSETS_DIR / "CodeMapRT_Table_Full_1-33.png"
OUT_GIF = ASSETS_DIR / "demo.gif"

def parse_table_rows(html_text):
    table_match = re.search(r"<table.*?>.*?</table>", html_text, re.S|re.I)
    if not table_match: return []
    table_html = table_match.group(0)
    rows = []
    for tr in re.findall(r"<tr.*?>(.*?)</tr>", table_html, re.S|re.I):
        cells = re.findall(r"<t[dh].*?>(.*?)</t[dh]>", tr, re.S|re.I)
        clean = [html.unescape(re.sub(r"<.*?>", "", c)).strip() for c in cells]
        rows.append(clean)
    return rows

def wrap(draw, text, font, max_w):
    words = text.split(); lines=[]; cur=""
    for w in words:
        test = (cur + " " + w).strip()
        if draw.textlength(test, font=font) <= max_w: cur = test
        else:
            if cur: lines.append(cur)
            cur = w
    if cur: lines.append(cur)
    return lines or [""]

def render_full_image(rows):
    W = 1600
    WHITE=(245,247,250); HEADER_BG=(230,230,230); TEXT=(40,40,40); TEXT_DIM=(80,80,80); BLUE=(31,59,115)
    try:
        title = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 30)
        header_f = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 22)
        ui = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 18)
    except: title = header_f = ui = ImageFont.load_default()
    x0,y0=40,200; widths=[70,880,140,400]; pad=12; table_header_h=40
    tmp = Image.new("RGB",(10,10),"white"); td=ImageDraw.Draw(tmp)
    def measure_row(tid, reason):
        tl = wrap(td, tid, ui, widths[1]-20); rl = wrap(td, reason, ui, widths[3]-20)
        return max(1, len(tl), len(rl)) * 26 + pad
    heights=[measure_row((row+['']*4)[:4][1], (row+['']*4)[:4][3]) for row in rows[1:]]
    H = 60+40+120+40+sum(heights)+40
    img = Image.new("RGB",(W,H),WHITE); d=ImageDraw.Draw(img)
    d.rectangle([0,0,W,60], fill=HEADER_BG)
    d.text((120,16),"reports/index.html — CodeMapRT Report", font=ui, fill=TEXT_DIM)
    d.text((40,90),"CodeMapRT — Prioritized Test Execution Report", font=title, fill=BLUE)
    d.text((40,130),"Report generated by CI from reports/index.html", font=ui, fill=TEXT_DIM)
    d.text((40,154),"This image and GIF are auto-built for README/demo purposes.", font=ui, fill=TEXT_DIM)
    headers=["#","Test ID","Score","Reason"]; x=x0
    for i,h in enumerate(headers):
        d.rectangle([x,y0,x+[70,880,140,400][i],y0+table_header_h], outline=(180,180,180), fill=(235,238,245))
        d.text((x+10,y0+10),h,font=header_f,fill=(50,50,50)); x+=[70,880,140,400][i]
    y=y0+table_header_h
    for ridx,row in enumerate(rows[1:], start=1):
        row=(row+['']*4)[:4]; tid,score,reason=row[1],row[2],row[3]
        row_h=measure_row(tid,reason); x=x0; fill=(255,255,255) if (ridx%2==0) else (248,248,248)
        d.rectangle([x,y,x+70,y+row_h], outline=(210,210,210), fill=fill); d.text((x+10,y+10),row[0],font=ui,fill=TEXT); x+=70
        d.rectangle([x,y,x+880,y+row_h], outline=(210,210,210), fill=fill); yy=y+10
        for line in wrap(d,tid,ui,880-20): d.text((x+10,yy),line,font=ui,fill=TEXT); yy+=26
        x+=880
        d.rectangle([x,y,x+140,y+row_h], outline=(210,210,210), fill=fill); d.text((x+10,y+10),score,font=ui,fill=TEXT); x+=140
        d.rectangle([x,y,x+400,y+row_h], outline=(210,210,210), fill=fill); yy=y+10
        for line in wrap(d,reason,ui,400-20): d.text((x+10,yy),line,font=ui,fill=TEXT); yy+=26
        y+=row_h
    return img

def build():
    if not REPORT.exists(): print("[make_full_gifs] reports/index.html not found; skip."); return
    rows = parse_table_rows(REPORT.read_text(encoding='utf-8', errors='ignore'))
    if not rows: print("[make_full_gifs] No table rows parsed; skip."); return
    full = render_full_image(rows); full.save(OUT_PNG)
    frames=[]; W,H=full.size[0],1200; max_scroll=max(0, full.size[1]-H); steps=24
    for s in range(steps):
        top=int(max_scroll*(s/(steps-1))); frames.append(full.crop((0,top,W,top+H)))
    imageio.mimsave(OUT_GIF, frames, duration=[0.9]*len(frames))
    print(f"[make_full_gifs] Built {OUT_PNG} and {OUT_GIF}")
if __name__=='__main__': build()
